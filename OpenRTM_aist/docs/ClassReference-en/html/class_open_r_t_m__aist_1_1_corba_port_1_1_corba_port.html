<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>OpenRTM-aist-1.1.0-Python: OpenRTM_aist.CorbaPort.CorbaPort Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenRTM-aist-1.1.0-Python</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><b>OpenRTM_aist</b>      </li>
      <li class="navelem"><b>CorbaPort</b>      </li>
      <li class="navelem"><a class="el" href="class_open_r_t_m__aist_1_1_corba_port_1_1_corba_port.html">CorbaPort</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>OpenRTM_aist.CorbaPort.CorbaPort Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="OpenRTM_aist::CorbaPort::CorbaPort" --><!-- doxytag: inherits="OpenRTM_aist::PortBase::PortBase" -->
<p>RT Conponent CORBA service/consumer Port.  
<a href="#_details">More...</a></p>
<div class="dynheader">
Inheritance diagram for OpenRTM_aist.CorbaPort.CorbaPort:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_open_r_t_m__aist_1_1_corba_port_1_1_corba_port.png" usemap="#OpenRTM_aist.CorbaPort.CorbaPort_map" alt=""/>
  <map id="OpenRTM_aist.CorbaPort.CorbaPort_map" name="OpenRTM_aist.CorbaPort.CorbaPort_map">
<area href="class_open_r_t_m__aist_1_1_port_base_1_1_port_base.html" alt="OpenRTM_aist.PortBase.PortBase" shape="rect" coords="0,0,219,24"/>
</map>
 </div></div>

<p><a href="class_open_r_t_m__aist_1_1_corba_port_1_1_corba_port-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_r_t_m__aist_1_1_corba_port_1_1_corba_port_1_1_corba_consumer_holder.html">CorbaConsumerHolder</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The structure to be stored Consumer information.  <a href="class_open_r_t_m__aist_1_1_corba_port_1_1_corba_port_1_1_corba_consumer_holder.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_r_t_m__aist_1_1_corba_port_1_1_corba_port_1_1_corba_provider_holder.html">CorbaProviderHolder</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The structure to be stored Provider information.  <a href="class_open_r_t_m__aist_1_1_corba_port_1_1_corba_port_1_1_corba_provider_holder.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_r_t_m__aist_1_1_corba_port_1_1_corba_port_1_1subscribe.html">subscribe</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscription mutching functor for Consumer.  <a href="class_open_r_t_m__aist_1_1_corba_port_1_1_corba_port_1_1subscribe.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_r_t_m__aist_1_1_corba_port_1_1_corba_port_1_1unsubscribe.html">unsubscribe</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor to release Consumer's object.  <a href="class_open_r_t_m__aist_1_1_corba_port_1_1_corba_port_1_1unsubscribe.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_r_t_m__aist_1_1_corba_port_1_1_corba_port.html#ad16447b2aeb15eefcd9c79c23cbe0ccd">__init__</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#ad16447b2aeb15eefcd9c79c23cbe0ccd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_r_t_m__aist_1_1_corba_port_1_1_corba_port.html#a3d21cd3f836e4cb1fc6418555c7f9a33">init</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializing properties.  <a href="#a3d21cd3f836e4cb1fc6418555c7f9a33"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_r_t_m__aist_1_1_corba_port_1_1_corba_port.html#a013135bddc550b9352acfcf23180076e">registerProvider</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the provider.  <a href="#a013135bddc550b9352acfcf23180076e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_r_t_m__aist_1_1_corba_port_1_1_corba_port.html#aa84d9e9db368dac68f6315b59379b9cf">registerConsumer</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the consumer.  <a href="#aa84d9e9db368dac68f6315b59379b9cf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_r_t_m__aist_1_1_corba_port_1_1_corba_port.html#aba2c11e378b962c20b716e9bf1f0cd9b">activateInterfaces</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Activate all Port interfaces.  <a href="#aba2c11e378b962c20b716e9bf1f0cd9b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_r_t_m__aist_1_1_corba_port_1_1_corba_port.html#abf24735936e626b8cc31cd121f01c191">deactivateInterfaces</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Deactivate all Port interfaces.  <a href="#abf24735936e626b8cc31cd121f01c191"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_r_t_m__aist_1_1_corba_port_1_1_corba_port.html#a4ec13c72c7c721cfbf5cbb7f2d9d8668">publishInterfaces</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish information about interfaces.  <a href="#a4ec13c72c7c721cfbf5cbb7f2d9d8668"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_r_t_m__aist_1_1_corba_port_1_1_corba_port.html#acc97fe8457851886eb7be0742e9a87f8">subscribeInterfaces</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe to interface.  <a href="#acc97fe8457851886eb7be0742e9a87f8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_r_t_m__aist_1_1_corba_port_1_1_corba_port.html#aa6a6f5540d0607b61f08146461f7761a">unsubscribeInterfaces</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe interfaces.  <a href="#aa6a6f5540d0607b61f08146461f7761a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_r_t_m__aist_1_1_corba_port_1_1_corba_port.html#a8d1225856e79e9bfd10276823d24230d">findProvider</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find out a provider corresponding to the consumer from NVList.  <a href="#a8d1225856e79e9bfd10276823d24230d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_r_t_m__aist_1_1_corba_port_1_1_corba_port.html#a4b145751dbed2a15eacbfbce5d8be265">findProviderOld</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find out a provider corresponding to the consumer from NVList.  <a href="#a4b145751dbed2a15eacbfbce5d8be265"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_r_t_m__aist_1_1_corba_port_1_1_corba_port.html#a1ff0ee99e45b99493605146c4ffa0651">setObject</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Setting IOR to Consumer.  <a href="#a1ff0ee99e45b99493605146c4ffa0651"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_r_t_m__aist_1_1_corba_port_1_1_corba_port.html#ac26932b9e7808ea005d77d9b5faa5eeb">releaseObject</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Releasing Consumer Object.  <a href="#ac26932b9e7808ea005d77d9b5faa5eeb"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>RT Conponent CORBA service/consumer Port. </p>
<div class="fragment"><pre class="fragment">
</pre></div><p><a class="el" href="class_open_r_t_m__aist_1_1_corba_port_1_1_corba_port.html" title="RT Conponent CORBA service/consumer Port.">CorbaPort</a> is an implementation of the Port of RT-Component's that provides user-defined CORBA Object Service and Consumer. </p>
<p>RT-Component can provide user-defined CORBA serivces, which is called RT-Serivce (Provider), through the Ports. RT-Component can also provide place-holder, which is called RT-Serivce Consumer, to use other RT-Component's service. </p>
<p>The <a class="el" href="class_open_r_t_m__aist_1_1_corba_port_1_1_corba_port.html" title="RT Conponent CORBA service/consumer Port.">CorbaPort</a> can manage any number of Providers and Consumers, can associate Consumers with correspondent Providers when establishing connection among Ports. </p>
<p>Usually, <a class="el" href="class_open_r_t_m__aist_1_1_corba_port_1_1_corba_port.html" title="RT Conponent CORBA service/consumer Port.">CorbaPort</a> is used like the following.</p>
<pre>
 RTC.CorbaPort m_port0; // declaration of Port</pre><pre> MyService_impl m_mysvc0; // Serivce Provider that is provided by the Port
 RTC.CorbaConsumer&lt;YourService&gt; m_cons0; // Consumer of the Port</pre><pre> // register Service Provider to the Port
 m_port0.registerProvider("MyService0", "Generic", m_mysvc0);
 // register Service Consumer to the Port
 m_port0.registerConsumer("YourService0", "Generic", m_cons0 );</pre><pre> // after connect established</pre><pre> m_cons0-&gt;your_service_function(); // call a YourService's function</pre><pre> // in another component that is connected with the Port
 m_cons1-&gt;my_service_function(); // call a MyService's function
 </pre><p>Registering Service Provider by <a class="el" href="class_open_r_t_m__aist_1_1_corba_port_1_1_corba_port.html#a013135bddc550b9352acfcf23180076e" title="Register the provider.">registerProvider()</a>, it can be used from other RT-Components. Registering Service Consumer by <a class="el" href="class_open_r_t_m__aist_1_1_corba_port_1_1_corba_port.html#aa84d9e9db368dac68f6315b59379b9cf" title="Register the consumer.">registerConsumer()</a>, other RT-Component's services can be used through the consumer object.</p>
<p>PortInterfaceProfile is a one of the profile information to store Provider interface and Consumer interface information. Tools or other RTCs should call one of the Port.connect() with an appropriate ConnectorProfile.</p>
<p>In addition, the instance name "*" declares a special type of instance.</p>
<p>When the name of the PROVIDED type interface that is the provider interface is "*", Provider interface's instance does not exist at the beginning of connection sequence. The instances will be created dynamically according to the consumer interface requirement at the connection sequence. Although the instance name does not exist at the beginning of connection sequence, the created providers shall publish its references to the ConnectorProfile with interface descriptor adequately in the interface publisher phase of the connection sequence.</p>
<p>If REQUIRED interface name that is Consumer interface name is "*", it shows that one Consumer interface is able to connect with multiple Provider interfaces. (This feature is not implemented.)</p>
<p>The following describes the rules that specify interface connection between ports.</p>
<p>The descriptor format of interfaces associated with Ports is declared as follows. Now some of interface properties are assumed as the followings.</p>
<ul>
<li><a class="el" href="namespace_r_t_c.html" title="RT-Component.">RTC</a> instance name: rtc_iname</li>
<li>Port name: port_name</li>
<li>Interface polarity: if_polarity</li>
<li>Interface type name: if_tname</li>
<li>INterface instance name: if_iname</li>
</ul>
<p>The interface descriptors shall be declared as follows.</p>
<p>&lt;rtc_iname&gt;.port.&lt;port_name&gt;.&lt;if_polarity&gt;.&lt;if_tname&gt;.&lt;if_iname&gt;</p>
<p>When PROVIDED that is Provider interface properties are the followings,</p>
<ul>
<li>rtc_iname = MyComp0</li>
<li>port_name = myservice</li>
<li>if_polarity = provided</li>
<li>if_tname = echo_interface</li>
<li>if_iname = echo_interface2 the interface descriptor is here.</li>
</ul>
<p>MyComp0.port.myservice.provided.echo_interface.echo_interface2</p>
<p>And, when REQUIRED that is Consumer interfaces properties are the followings,</p>
<ul>
<li>rtc_iname = YourComp0</li>
<li>port_name = yourservice</li>
<li>if_polarity = required</li>
<li>if_tname = hoge_interface</li>
<li>if_iname = hoge_interface1</li>
</ul>
<p>interface descriptor is as follows.</p>
<p>YourComp0.port.myservice.required.hoge_interface.hoge_inteface1</p>
<p>Specific instance name descriptors that are dynamically generated at the connection time are defined here.</p>
<ul>
<li>&lt;type_name&gt;*: "Dynamically generated" instance descriptor.</li>
<li>&lt;type_name&gt;+: "Incrementally generated" instance descriptor.</li>
</ul>
<p>When the "Dynamically generated" instance descriptor: "&lt;type_name&gt;*" is specified as interface descriptor that is required by consumers, the provider will generate a instance. If n consumers who demand a provider by the "&lt;type_name&gt;" descriptor exist, the following relation which processes the call from these consumers by one provider will be established.</p>
<pre>
 consumer0 ]---&lt;
 consumer1 ]---&lt;  O----[ provider0
 consumer2 ]---&lt;
 </pre><p>On the other hand, when incremental generated type instance name descriptor "&lt;type_name&gt;+" is specified as the provider interface descriptor whom consumers demand, provider's instances are dynamically generated for the number of the descriptors "&lt;type_name&gt;+". When n consumers who demand a provider by the descriptor "&lt;type_name&gt;+" exist the following relations in which n providers process each call from the consumers will be established.</p>
<pre>
 consumer0 ]---&lt;  O----[ provider0
 consumer1 ]---&lt;  O----[ provider1
 consumer2 ]---&lt;  O----[ provider2
 </pre><p>Describing the appropriate interface mapping specification in the ConnectorProfile.properties, selective connections between providers/consumers interface can be established at the time of connection. However, when different <a class="el" href="namespace_r_t_c.html" title="RT-Component.">RTC</a> instances of the same instance name exist in a connection, since an interface descriptor uniqueness cannot be guaranteed, this connection mapping rules cannot be used.</p>
<p>Here, assume that an interface descriptor is given as &lt;if_desc0&gt;, &lt;if_desc1&gt;, .... And assume that the key and the value of NVList in ConnectorProfile.properties are given as "key: value".</p>
<p>Now the case where the service ports of two components are connected is considered. When the service port of each component is the following,</p>
<ul>
<li>rtc_iname: MyComp0 <br/>
 port_name: mycomp_service <br/>
 interfaces:<ul>
<li>if_polarity: provided <br/>
 if_iname: echo0 <br/>
 if_tname: Echo</li>
<li>if_polarity: required <br/>
 if_iname: add0 <br/>
 if_tname: add</li>
</ul>
</li>
</ul>
<ul>
<li>rtc_iname: YourComp0 <br/>
 port_name: yourcomp_service <br/>
 interfaces:<ul>
<li>if_polarity: required <br/>
 if_iname: echo9 <br/>
 if_tname: Echo</li>
<li>if_polarity: provided <br/>
 if_iname: add9 <br/>
 if_tname: add</li>
</ul>
</li>
</ul>
<pre>
      MyComp0                                 YourComp0
     _______ mycomp_service   yourcomp_service ______
            |                                 |
          |~~~|---O echo0         echo9 &gt;---|~~~|
          |   |---&lt; add0          add9  O---|   |
           ~T~                               ~T~
            |                                 |
 </pre><p>Assume that connection between echo0 (provider) of MyComp0 component and echo9 (consumer) of YourComp0 component, and add0 (consumer) of MyComp0 and add0 (provider) of YourComp0 is established. In this case, ConnectorProfile is set up as follows.</p>
<pre>
 ConnectorProfile:
   name: any connector name
   connector_id: empty string
   ports[]: mycomp_service's reference, yourcomp_service's reference
   properties:
     &lt;add0&gt;: &lt;add9&gt;
     &lt;echo9&gt;: &lt;echo0&gt;
 </pre><p>Please note that &lt;add0&gt;, &lt;add9&gt;, &lt;echo0&gt; and &lt;echo9&gt; are the following.</p>
<pre>
 &lt;add0&gt; is MyComp0.port.mycomp_service.required.add.add0
 &lt;add9&gt; is YourComp0.port.yourcomp_service.provided.add.add9
 &lt;echo0&gt; is MyComp0.port.mycomp_service.provided.echo.echo0
 &lt;echo9&gt; is YourComp0.port.yourcomp_service.required.echo.echo9
 </pre><p>In the connection process, the provider and the consumer of each port carries out the following process respectively in the virtual functions such as <a class="el" href="class_open_r_t_m__aist_1_1_corba_port_1_1_corba_port.html#a4ec13c72c7c721cfbf5cbb7f2d9d8668" title="Publish information about interfaces.">CorbaPort.publishInterfaces()</a> and CorbaPort.subscribeInerfaces().</p>
<p>A provider sets its IOR string as a value and its interface descriptor as a key in the ConnectorProfile.properties in a <a class="el" href="class_open_r_t_m__aist_1_1_corba_port_1_1_corba_port.html#a4ec13c72c7c721cfbf5cbb7f2d9d8668" title="Publish information about interfaces.">publishInterfaces()</a> function. Since this interface descriptor's uniqueness is guaranteed in the current connector, the key of NameValue in the ConnectorProfile.properties is unique.</p>
<p>[This functionalities are not implemented] The dynamically generated provider is processed according to the following procedure. The publishInterface() function scans dynamic instance descriptors such as "&lt;type_name&gt;*" and "&lt;type_name&gt;+" in the ConnectorProfile.properties. When the dynamic generation instance descriptor "&lt;tupe_name&gt;*" exists, one instance of provider is generated, and its descriptor and its IOR string are set to ConnectorProfile.properties as the key and the value respectively. Simultaneously, in the ConnectorProfile.properties, all the instance descriptor with the dynamic generation instance name "&lt;type_name&gt;*" will be replaced with newly generated instance descriptor.</p>
<p>When the incremental dynamic generation instance descriptor exists, providers are generated for the number of the descriptors, and its descriptor and its IOR string are set to ConnectorProfile.properties as the key and the value respectively. Simultaneously, in the ConnectorProfile.properties, all the instance descriptor with the dynamic generation instance name "&lt;type_name&gt;+" will be replaced with newly generated instance descriptor.</p>
<p>The providers do not perform particular operation in <a class="el" href="class_open_r_t_m__aist_1_1_corba_port_1_1_corba_port.html#acc97fe8457851886eb7be0742e9a87f8" title="Subscribe to interface.">subscribeInterfaces()</a> function.</p>
<p>The consumers do not perform particular operation in publisherInterfaces() function.</p>
<p>On the other hand, a consumer searches a key-value pair with the key of consumer interface descriptor, and if the pair exists, it obtains provider's descriptor from the value. The consumer searches again a key-value pair with the key of provider interface descriptor, and it obtains provider's reference and the reference is set as the consumer's service object. In addition, reserved string "nil" or "null" are used not to set specific provider.</p>
<p>If consumer's interface descriptors does not exists in the ConnectorProfile.properties, the consumer searches a provider with same type name and instance name, and its reference is set to the consumer. This rule is for only backward compatibility, and it is not recommended from version 1.0.</p>
<p>The correspondence of a provider versus a consumer does not need to be one to one, and the case of one provider to n-consumers and the case of m-providers to one consumer are allowed. The one provider to n-consumers case can be realized by the above mentioned methods. The one consumer to m-provider case can be specified to set the consumer descriptor and comma-separated provider descriptors into the key and the value respectively.</p>
<p>The following option is available to specify the strictness of interfaces connection.</p>
<p>port.connection.strictness: strict, best_effort</p>
<p>strict: The connection is established, if only all the specified consumers are set appropriate references and narrowed successfully.</p>
<p>best_effort: The connection is established without any errors, even if appropriate reference does not exist or reference narrowing fails.</p>
<dl class="since"><dt><b>Since:</b></dt><dd>0.4.0 </dd></dl>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ad16447b2aeb15eefcd9c79c23cbe0ccd"></a><!-- doxytag: member="OpenRTM_aist::CorbaPort::CorbaPort::__init__" ref="ad16447b2aeb15eefcd9c79c23cbe0ccd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def OpenRTM_aist.CorbaPort.CorbaPort.__init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of Port </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_open_r_t_m__aist_1_1_port_base_1_1_port_base.html#a73c73828d1dd0fccd4d41a66a19fe811">OpenRTM_aist.PortBase.PortBase</a>.</p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="aba2c11e378b962c20b716e9bf1f0cd9b"></a><!-- doxytag: member="OpenRTM_aist::CorbaPort::CorbaPort::activateInterfaces" ref="aba2c11e378b962c20b716e9bf1f0cd9b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def OpenRTM_aist.CorbaPort.CorbaPort.activateInterfaces </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Activate all Port interfaces. </p>
<p>This operation activate all interfaces that is registered in the ports.</p>
<p>void <a class="el" href="class_open_r_t_m__aist_1_1_corba_port_1_1_corba_port.html#aba2c11e378b962c20b716e9bf1f0cd9b" title="Activate all Port interfaces.">CorbaPort.activateInterfaces()</a> </p>

</div>
</div>
<a class="anchor" id="abf24735936e626b8cc31cd121f01c191"></a><!-- doxytag: member="OpenRTM_aist::CorbaPort::CorbaPort::deactivateInterfaces" ref="abf24735936e626b8cc31cd121f01c191" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def OpenRTM_aist.CorbaPort.CorbaPort.deactivateInterfaces </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deactivate all Port interfaces. </p>
<p>This operation deactivate all interfaces that is registered in the ports.</p>
<p>void <a class="el" href="class_open_r_t_m__aist_1_1_corba_port_1_1_corba_port.html#abf24735936e626b8cc31cd121f01c191" title="Deactivate all Port interfaces.">CorbaPort.deactivateInterfaces()</a> </p>

</div>
</div>
<a class="anchor" id="a8d1225856e79e9bfd10276823d24230d"></a><!-- doxytag: member="OpenRTM_aist::CorbaPort::CorbaPort::findProvider" ref="a8d1225856e79e9bfd10276823d24230d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def OpenRTM_aist.CorbaPort.CorbaPort.findProvider </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iorstr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find out a provider corresponding to the consumer from NVList. </p>
<p>This function finds out a Provider with the key that is matched with Cosumer's name in the <a class="el" href="class_open_r_t_m__aist_1_1_corba_port_1_1_corba_port_1_1_corba_consumer_holder.html" title="The structure to be stored Consumer information.">CorbaConsumerHolder</a>, extracts IOR and performs narrowing into the Consumer and set it to the Consumer. False is returned when there is no corresponding key and IOR and the narrowing failed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">nv</td><td>NVlist of ConnectorProfile.properties that includes Provider </td></tr>
    <tr><td class="paramname">cons</td><td>a Consumer holder to be matched with a Provider</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>bool false is returned if there is no provider for the consumer</dd></dl>
<p>virtual bool findProvider(const NVList&amp; nv, <a class="el" href="class_open_r_t_m__aist_1_1_corba_port_1_1_corba_port_1_1_corba_consumer_holder.html" title="The structure to be stored Consumer information.">CorbaConsumerHolder</a>&amp; cons, std.string&amp; iorstr); </p>

</div>
</div>
<a class="anchor" id="a4b145751dbed2a15eacbfbce5d8be265"></a><!-- doxytag: member="OpenRTM_aist::CorbaPort::CorbaPort::findProviderOld" ref="a4b145751dbed2a15eacbfbce5d8be265" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def OpenRTM_aist.CorbaPort.CorbaPort.findProviderOld </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iorstr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find out a provider corresponding to the consumer from NVList. </p>
<p>This function is for the old version's compatibility.</p>
<p>This function finds out a Provider with the key that is matched with Cosumer's name in the <a class="el" href="class_open_r_t_m__aist_1_1_corba_port_1_1_corba_port_1_1_corba_consumer_holder.html" title="The structure to be stored Consumer information.">CorbaConsumerHolder</a> and extracts IOR. False is returned when there is no corresponding key and IOR.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">nv</td><td>NVlist of ConnectorProfile.properties that includes Provider </td></tr>
    <tr><td class="paramname">cons</td><td>a Consumer holder to be matched with a Provider </td></tr>
    <tr><td class="paramname">iorstr</td><td>variable which is set IOR string</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>bool false is returned if there is no provider for the consumer</dd></dl>
<p>virtual bool findProviderOld(const NVList&amp;nv, <a class="el" href="class_open_r_t_m__aist_1_1_corba_port_1_1_corba_port_1_1_corba_consumer_holder.html" title="The structure to be stored Consumer information.">CorbaConsumerHolder</a>&amp; cons, std.string&amp; iorstr); </p>

</div>
</div>
<a class="anchor" id="a3d21cd3f836e4cb1fc6418555c7f9a33"></a><!-- doxytag: member="OpenRTM_aist::CorbaPort::CorbaPort::init" ref="a3d21cd3f836e4cb1fc6418555c7f9a33" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def OpenRTM_aist.CorbaPort.CorbaPort.init </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>prop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initializing properties. </p>
<p>This operation initializes outport's properties. If a property "connection_limit" is set and appropriate value is set to this property value, the number of maximum connection is set as this value. If the property does not exist or invalid value is set to this property, the maximum number of connection will be set unlimited.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">prop</td><td>properties of the <a class="el" href="class_open_r_t_m__aist_1_1_corba_port_1_1_corba_port.html" title="RT Conponent CORBA service/consumer Port.">CorbaPort</a></td></tr>
  </table>
  </dd>
</dl>
<p>void init(coil.Properties&amp; prop); </p>

</div>
</div>
<a class="anchor" id="a4ec13c72c7c721cfbf5cbb7f2d9d8668"></a><!-- doxytag: member="OpenRTM_aist::CorbaPort::CorbaPort::publishInterfaces" ref="a4ec13c72c7c721cfbf5cbb7f2d9d8668" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def OpenRTM_aist.CorbaPort.CorbaPort.publishInterfaces </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>connector_profile</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Publish information about interfaces. </p>
<p>This operation publishes Provider interfaces information, which is owned by this port, to the other Ports via ConnectorProfile.properties. Now it is assumed <a class="el" href="namespace_r_t_c.html" title="RT-Component.">RTC</a> instance name and other information is as follows,</p>
<ul>
<li><a class="el" href="namespace_r_t_c.html" title="RT-Component.">RTC</a> instance name: rtc_iname</li>
<li>Port name: port_name</li>
<li>Interface polarity: if_polarity</li>
<li>Interface type name: if_tname</li>
<li>Interface instance name: if_iname</li>
</ul>
<p>the following values are stored as the "name" and the "value" of the NameValue typee element in ConnectorProfile.properties.</p>
<ul>
<li>name &lt;rtc_iname&gt;.port.&lt;port_name&gt;.provided.&lt;if_tname&gt;.&lt;if_iname&gt;</li>
<li>value IOR string value of interface reference</li>
</ul>
<p>In addition, although the following NameValue values are also stored for the backward compatibility, this will be deleted in the future version.</p>
<ul>
<li>name port.&lt;if_tname&gt;.&lt;if_iname&gt;</li>
<li>value IOR string value of interface reference</li>
</ul>
<p>These values are stored in the ConnectorProfile.properties and are propagated to the other Ports. If the Consumer interface exists that requires this Provider interface, it will retrieve reference from the ConnectorProfile and utilize it.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">connector_profile</td><td>Connector profile </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The return code of ReturnCode_t type</dd></dl>
<p>virtual ReturnCode_t publishInterfaces(ConnectorProfile&amp; connector_profile); </p>

<p>Reimplemented from <a class="el" href="class_open_r_t_m__aist_1_1_port_base_1_1_port_base.html#a11e7568edaff9ae52dfb1000d904be29">OpenRTM_aist.PortBase.PortBase</a>.</p>

</div>
</div>
<a class="anchor" id="aa84d9e9db368dac68f6315b59379b9cf"></a><!-- doxytag: member="OpenRTM_aist::CorbaPort::CorbaPort::registerConsumer" ref="aa84d9e9db368dac68f6315b59379b9cf" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def OpenRTM_aist.CorbaPort.CorbaPort.registerConsumer </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>instance_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>type_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>consumer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Register the consumer. </p>
<p>This operation registers a consumer, which is a service placeholder this port requires. These are associated internally with specified instance_name, type_name and Consumer itself to the argument as service's instance name and its type name associated with Consumer. The service Provider interface' references will be set automatically to the Consumer Interface object when connections are established, according to the rules that are described at the <a class="el" href="class_open_r_t_m__aist_1_1_corba_port_1_1_corba_port.html#acc97fe8457851886eb7be0742e9a87f8" title="Subscribe to interface.">subscribeInterfaces()</a> function's documentation.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">instance_name</td><td>Instance name of the service Consumer requires </td></tr>
    <tr><td class="paramname">type_name</td><td>Type name of the service Consumer requires </td></tr>
    <tr><td class="paramname">consumer</td><td>CORBA service consumer</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>False would be returned if the same instance_name was registered</dd></dl>
<p>bool registerConsumer(const char* instance_name, const char* type_name, CorbaConsumerBase&amp; consumer); </p>

</div>
</div>
<a class="anchor" id="a013135bddc550b9352acfcf23180076e"></a><!-- doxytag: member="OpenRTM_aist::CorbaPort::CorbaPort::registerProvider" ref="a013135bddc550b9352acfcf23180076e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def OpenRTM_aist.CorbaPort.CorbaPort.registerProvider </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>instance_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>type_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>provider</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Register the provider. </p>
<p>This operation registers a servant, which is provided in this Port, to the Port. The servant is associated with "instance_name" and "type_name" as the instance name of the servant and as the type name of the servant. A given servant will be stored in the <a class="el" href="class_open_r_t_m__aist_1_1_corba_port_1_1_corba_port.html" title="RT Conponent CORBA service/consumer Port.">CorbaPort</a>, and this is registered as RTC.PROVIDED interface into the PortInterfaceProfile.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">instance_name</td><td>Instance name of servant </td></tr>
    <tr><td class="paramname">type_name</td><td>Type name of the servant </td></tr>
    <tr><td class="paramname">provider</td><td>CORBA servant</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Return false if the same name of instance_name is already registered.</dd></dl>
<p>bool registerProvider(const char* instance_name, const char* type_name, PortableServer.RefCountServantBase&amp; provider); </p>

</div>
</div>
<a class="anchor" id="ac26932b9e7808ea005d77d9b5faa5eeb"></a><!-- doxytag: member="OpenRTM_aist::CorbaPort::CorbaPort::releaseObject" ref="ac26932b9e7808ea005d77d9b5faa5eeb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def OpenRTM_aist.CorbaPort.CorbaPort.releaseObject </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ior</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cons</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Releasing Consumer Object. </p>
<p>This function releases object reference of Consumer. If the given IOR string is different from Consumer's IOR string, it returns false.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ior</td><td>IOR string </td></tr>
    <tr><td class="paramname">cons</td><td>Consumer holder</td></tr>
  </table>
  </dd>
</dl>
<p>bool False if IOR and Consumer's IOR are different</p>
<p>bool releaseObject(const std.string&amp; ior, CorbaConsumerHolder&amp; cons); </p>

</div>
</div>
<a class="anchor" id="a1ff0ee99e45b99493605146c4ffa0651"></a><!-- doxytag: member="OpenRTM_aist::CorbaPort::CorbaPort::setObject" ref="a1ff0ee99e45b99493605146c4ffa0651" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def OpenRTM_aist.CorbaPort.CorbaPort.setObject </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ior</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cons</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Setting IOR to Consumer. </p>
<p>This function performs narrowing into the Consumer and set it to the Consumer. False is returned when the narrowing failed. But, if IOR string is "null" or "nil", this function returns true.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ior</td><td>IOR string </td></tr>
    <tr><td class="paramname">cons</td><td>Consumer holder</td></tr>
  </table>
  </dd>
</dl>
<p>bool false if narrowing failed.</p>
<p>bool setObject(const std.string&amp; ior, CorbaConsumerHolder&amp; cons); </p>

</div>
</div>
<a class="anchor" id="acc97fe8457851886eb7be0742e9a87f8"></a><!-- doxytag: member="OpenRTM_aist::CorbaPort::CorbaPort::subscribeInterfaces" ref="acc97fe8457851886eb7be0742e9a87f8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def OpenRTM_aist.CorbaPort.CorbaPort.subscribeInterfaces </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>connector_profile</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Subscribe to interface. </p>
<p>Retrieve information associated with Provider matches Consumer owned by this port and set the object reference to Consumer.</p>
<p>Now, Consumer is registered as the following: </p>
<pre>
  PortInterfaceProfile
  {
    instance_name = "PA10_0";
    type_name     = "Manipulator";
    polarity      = REQUIRED;
  }
 </pre><p> Find the object reference of Serivce Provider that is registered as the following of other ports: </p>
<pre>
  PortInterfaceProfile
  {
    instance_name = "PA10_0";
    type_name     = "Manipulator";
    polarity      = PROVIDED;
  }
 </pre><p> and set to Consumer. In fact, find NameValue that is registered as the following to ConnectorProfile.properties: </p>
<pre>
 NameValue = { "port.Manipulator.PA10_0": &lt;Object reference&gt;=""&gt; }
 </pre><p> and set the object reference to Consumer.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">connector_profile</td><td>Connector profile</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The return code of ReturnCode_t type</dd></dl>
<p>virtual ReturnCode_t subscribeInterfaces(const ConnectorProfile&amp; connector_profile); </p>

<p>Reimplemented from <a class="el" href="class_open_r_t_m__aist_1_1_port_base_1_1_port_base.html#a756697caff48b6cb715c5baec70cdfe6">OpenRTM_aist.PortBase.PortBase</a>.</p>

</div>
</div>
<a class="anchor" id="aa6a6f5540d0607b61f08146461f7761a"></a><!-- doxytag: member="OpenRTM_aist::CorbaPort::CorbaPort::unsubscribeInterfaces" ref="aa6a6f5540d0607b61f08146461f7761a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def OpenRTM_aist.CorbaPort.CorbaPort.unsubscribeInterfaces </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>connector_profile</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unsubscribe interfaces. </p>
<p>Release all Objects that was set in Consumer associated with the given ConnectorProfile.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">connector_profile</td><td>Connector profile</td></tr>
  </table>
  </dd>
</dl>
<p>virtual void unsubscribeInterfaces(const ConnectorProfile&amp; connector_profile); </p>

<p>Reimplemented from <a class="el" href="class_open_r_t_m__aist_1_1_port_base_1_1_port_base.html#a9911af65361bee72de183c6d6e1e22ad">OpenRTM_aist.PortBase.PortBase</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/openrtm/svn/OpenRTM-aist-Python/OpenRTM_aist/<a class="el" href="_corba_port_8py.html">CorbaPort.py</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Oct 4 2011 14:06:21 for OpenRTM-aist-1.1.0-Python by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
